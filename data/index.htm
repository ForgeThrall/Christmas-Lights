<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Christmas Lights</title>
	<link rel="icon" type="image/svg+xml" sizes="any" href="favicon.svg"/>
	<script>
		function init() {
			ColorPicker.initAll();
			PaletteSelector.initAll();
		}

		class ColorPicker {
			hsv = {h: 0, s: .5, v: .5};
			pickerElement;
			callback;
			hueContainer;
			satContainer;
			valContainer;

			constructor(element) {
				element.insertAdjacentHTML("afterbegin",
					`<div class="dial-container">
						<div class="dial-ring"></div>
						<div class="dial-cursor"></div>
					</div>
					<div class="slider-container sat">
						<div class="slider-bar sat"></div>
						<div class="slider-cursor sat"></div>
					</div>
					<div class="slider-container val">
						<div class="slider-bar val"></div>
						<div class="slider-cursor val"></div>
					</div>`
				);
				this.pickerElement = element;
				this.callback = window[element.getAttribute("listener")];
				this.hueContainer = this.pickerElement.getElementsByClassName("dial-container")[0];
				this.satContainer = this.pickerElement.getElementsByClassName("slider-container sat")[0];
				this.valContainer = this.pickerElement.getElementsByClassName("slider-container val")[0];
				
				ColorPicker.dragBootstrap(this.hueContainer, this.hueDialDrag.bind(this));
				ColorPicker.dragBootstrap(this.satContainer, this.satSliderDrag.bind(this));
				ColorPicker.dragBootstrap(this.valContainer, this.valSliderDrag.bind(this));
			}

			static initAll(){
				Array.from(document.getElementsByClassName("color-picker")).forEach(element => {
					new ColorPicker(element);
				});
			}

			hueDialDrag(e) {
				let rect = this.hueContainer.getBoundingClientRect();
				let xTarget = e.pageX - rect.x - rect.width/2;
				let yTarget = e.pageY - rect.y - rect.height/2;
				let t = Math.atan2(yTarget, xTarget);

				let hue = ColorPicker.rangeMap(t, -Math.PI, Math.PI, 0, 1, -Math.PI/2);
				this.updateColor(hue, null, null);
			}

			satSliderDrag(e) {
				let rect = this.satContainer.getBoundingClientRect();
				let x = Math.max(0, Math.min(e.pageX - rect.x, rect.width));
				let sat = ColorPicker.rangeMap(x, 0, rect.width, 0, 1);
				this.updateColor(null, sat, null);
			}

			valSliderDrag(e) {
				let rect = this.valContainer.getBoundingClientRect();
				let x = Math.max(0, Math.min(e.pageX - rect.x, rect.width));
				let val = ColorPicker.rangeMap(x, 0, rect.width, 0, 1);
				this.updateColor(null, null, val);
			}

			updateColor(h, s, v) {
				this.hsv.h = h ?? this.hsv.h;
				this.hsv.s = s ?? this.hsv.s;
				this.hsv.v = v ?? this.hsv.v;

				this.pickerElement.style.setProperty("--hsv-h", this.hsv.h);
				this.pickerElement.style.setProperty("--hsv-s", this.hsv.s);
				this.pickerElement.style.setProperty("--hsv-v", this.hsv.v);

				let r, g, b;
				[r, g, b] = ColorPicker.hsvToRgb(this.hsv.h, 1, 1);
				this.pickerElement.style.setProperty("--rgb-h", `rgb(${r}, ${g}, ${b})`);
				[r, g, b] = ColorPicker.hsvToRgb(this.hsv.h, this.hsv.s, 1);
				this.pickerElement.style.setProperty("--rgb-hs", `rgb(${r}, ${g}, ${b})`);
				[r, g, b] = ColorPicker.hsvToRgb(this.hsv.h, this.hsv.s, this.hsv.v);
				this.pickerElement.style.setProperty("--rgb-hsv", `rgb(${r}, ${g}, ${b})`);

				this.callback(this.hsv);
			}
			
			static dragBootstrap(element, handler) {
				element.addEventListener("mousedown", (e) => {
					document.addEventListener("mousemove", handler);
					document.addEventListener("mouseup", function () {
						document.removeEventListener("mousemove", handler)
					}, {once: true});
					handler(e);
				})
			}

			static rangeMap(val, inMin, inMax, outMin, outMax, inOffset = 0) {
				let inSpan = inMax - inMin;
				let outSpan = outMax - outMin;

				val += inOffset;
				if(val < inMin) val += inSpan;
				if(val > inMax) val -= inSpan;

				val -= inMin;
				val *= outSpan/inSpan;
				val += outMin;

				return val;
			}

			// https://axonflux.com/handy-rgb-to-hsl-and-rgb-to-hsv-color-model-c
			// h, s, v âˆˆ [0, 1]
			static hsvToRgb(h, s, v){
				var r, g, b;

				var i = Math.floor(h * 6);
				var f = h * 6 - i;
				var p = v * (1 - s);
				var q = v * (1 - f * s);
				var t = v * (1 - (1 - f) * s);

				switch(i % 6){
					case 0: r = v, g = t, b = p; break;
					case 1: r = q, g = v, b = p; break;
					case 2: r = p, g = v, b = t; break;
					case 3: r = p, g = q, b = v; break;
					case 4: r = t, g = p, b = v; break;
					case 5: r = v, g = p, b = q; break;
				}

				return [r * 255, g * 255, b * 255];
			}
		}

		class PaletteSelector {
			active = 0;
			size = 3;
			paletteElement;
			callback;

			constructor(element) {
				// Is there an elegant to inflate this with an arbitrary number
				// of palette divs including unique indicies?
				element.insertAdjacentHTML("afterbegin",
				`<div class="decrease"></div>
				<div class="palette" index="0">Testing</div>
				<div class="palette" index="1">one</div>
				<div class="palette" index="2">two</div>
				<div class="palette" index="3">three</div>
				<div class="palette" index="4">four</div>
				<div class="increase"></div>`
				);
				this.paletteElement = element;
				this.callback = window[element.getAttribute("listener")];

				Array.from(element.getElementsByClassName("palette")).forEach( element => {
					element.addEventListener("mousedown", this.paletteSelect.bind(this));
				});
			}

			paletteSelect(e) {
				this.callback.onIndexChange(e.target.getAttribute("index"));
			}

			static initAll(){
				Array.from(document.getElementsByClassName("palette-selector")).forEach(element => {
					new PaletteSelector(element);
				});
			}
		}

		class Controller {
			static socket;

			initSocket() {
				if(["","localhost"].includes(`${window.location.hostname}`)){ // when the webpage is loaded locally for testing
					socket = new WebSocket(`ws://192.168.0.1:81`);
				} else {
					socket = new WebSocket(`ws://${window.location.hostname}:81`);
				}

				socket.binaryType = 'arraybuffer';
				socket.onopen = (e) => {console.log("opened connection");}
				socket.onclose = (e) => {console.log("closed connection");}
				socket.onmessage = (e) => {
					console.log("received message");
					let data = new Uint8Array(e.data);
					consol.log(data);
				}
			}

			sendCommandToServer(...args) {
				if(socket.readyState != WebSocket.OPEN) return;
				socket.send(Uint8Array.from(args.flat()).buffer);
			}
		}

		paletteListener = {
			onIndexChange(index) {
				console.log(`index: ${index}`);
			},
			onCountChange(count) {
				console.log(`count: ${count}`)
			}
		}
		
		function onColorChange(hsv) {
			console.log(hsv);
		}
	</script>

	<style>
		:root {
			--background-color: #1d1d1f;
		}
		html,body {
			width:  100%;
			height: 100%;
			margin: 0%;
			padding: 0%;
			background-color: var(--background-color);
			cursor: default;
		}

		.color-picker {
			display: inline-block;
			width: 200px;
			margin-left: 100px;
			margin-top: 50px;
		}

		.color-picker {
			--background-color: #1d1d1f;
			/* in percents of dial diameter */
			--line-thickness: 5;
			--indicator-size: 40;
			--dial-cursor-size: 18;
			--slider-cursor-size: 15;
			position: relative;
			background: var(--background-color);
			--hsv-h: 1;
			--hsv-s: .5;
			--hsv-v: .5;
			--rgb-h: #F00;
			--rgb-hs: #FF8080;
			--rgb-hsv: #804040;
		}
		.color-picker,
		.color-picker *,
		.color-picker *::after {
			user-select: none;
			box-sizing: border-box;
		}

		.dial-container {
			position: relative;
			width: 100%;
			padding-top: 100%;
		}
		/* centered circle */
		/* TODO: css precompiler with mixins */
		.dial-ring,
		.dial-ring::before,
		.dial-ring::after,
		.dial-cursor,
		.dial-cursor::after,
		.slider-cursor,
		.slider-cursor::after {
			position: absolute;
			top: 50%; left: 50%;
			transform: translate(-50%, -50%);
			border-radius: 50%;
		}
		.dial-ring {
			width: 100%; height: 100%;
			background: conic-gradient(#F00, #FF0, #0F0, #0FF, #00F, #F0F, #F00);
		}
		.dial-ring::before {
			content: '';
			width: calc(100% - var(--line-thickness)*2*1%);
			height: calc(100% - var(--line-thickness)*2*1%);
			background: var(--background-color);
		}
		.dial-ring::after {
			content: '';
			width: calc(var(--indicator-size)*1%);
			height: calc(var(--indicator-size)*1%);
			background: var(--rgb-hs);
		}
		.dial-cursor {
			transform: translate(-50%, -50%)
				rotate(calc(var(--hsv-h) * 360deg))
				translateY(calc(-100% * ((50 - var(--line-thickness)/2)/var(--dial-cursor-size))));
			width: calc(var(--dial-cursor-size)*1%);
			height: calc(var(--dial-cursor-size)*1%);
			background: var(--background-color);
		}
		.dial-cursor::after {
			content: '';
			width: 80%; height: 80%;
			background: var(--rgb-h);
		}

		.slider-container {
			position: relative;
			width: 100%;
			margin-top: 20px;
			padding-top: calc(var(--slider-cursor-size)*1%);
		}
		.slider-bar {
			position: absolute;
			top: 50%; left: 50%;
			transform: translate(-50%, -50%);
			width: 100%;
			height: calc(100%*var(--line-thickness)/var(--slider-cursor-size));
			border-radius: 10000px;
		}
		.slider-cursor {
			width: calc(var(--slider-cursor-size)*1%);
			background: var(--background-color);
			height: 100%;
		}

		.slider-bar.sat {
			background: linear-gradient(90deg, #FFF, var(--rgb-h));
		}
		.slider-cursor.sat {
			left: calc(var(--hsv-s) * 100%);
		}
		.slider-cursor.sat::after {
			content: '';
			width: 80%; height: 80%;
			background: var(--rgb-hs);
		}

		.slider-bar.val {
			background: linear-gradient(90deg, #000, var(--rgb-hs));
		}
		.slider-cursor.val {
			left: calc(var(--hsv-v) * 100%);
		}
		.slider-cursor.val::after {
			content: '';
			width: 80%; height: 80%;
			background: var(--rgb-hsv);
		}
	</style>
</head>
<body>
	<div class="palette-selector" listener="paletteListener"></div>
	<div class="color-picker" listener="onColorChange"></div>
</body>
</html>
<script>
	init();
</script>